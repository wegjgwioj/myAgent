将评价指标分为两大阵营：**分类（Classification）** 和 **回归（Regression）**。

-----

# 专题：机器学习模型评价指标全解

## 第一部分：分类模型指标 (Classification Metrics)

**场景：** 预测离散的类别（如：是/否，猫/狗/鸟）。

### 1\. 混淆矩阵 (Confusion Matrix) —— 一切的基础

所有的分类指标几乎都源自这里。它是一个 $2 \times 2$ 的表格（二分类时）：

| | 预测为正 (Predicted 1) | 预测为负 (Predicted 0) |
| :--- | :--- | :--- |
| **真实为正 (Actual 1)** | **TP (真阳性)** - 抓对了 | **FN (假阴性)** - 漏抓了 |
| **真实为负 (Actual 0)** | **FP (假阳性)** - 抓错人了 | **TN (真阴性)** - 没抓错 |

### 2\. 准确率 (Accuracy)

$$Accuracy = \frac{TP + TN}{TP + TN + FP + FN}$$

  * **含义：** 猜对的比例是多少？
  * **致命陷阱：** **样本不平衡**。
      * *例子：* 如果 99% 的样本是负类，模型只要全猜“负”，准确率就是 99%，但模型毫无用处。

### 3\. 精确率 (Precision) 与 召回率 (Recall) —— 此消彼长的矛盾体

这两个指标通常是矛盾的，需要根据业务场景取舍。

  * **精确率 (Precision) —— “查准率”**
    $$Precision = \frac{TP}{TP + FP}$$

      * **含义：** 在你预测为正的样本中，有多少是真的正？
      * **场景：** **宁缺毋滥**。例如：垃圾邮件拦截（不想把正常邮件误判为垃圾邮件）、推荐系统（推荐给用户的要是他真正喜欢的）。
      * *口诀：* “我报出来的，必须是对的。”

  * **召回率 (Recall) —— “查全率”**
    $$Recall = \frac{TP}{TP + FN}$$

      * **含义：** 在所有真的正样本中，你找出了多少？
      * **场景：** **宁可错杀一千，不可放过一个**。例如：癌症筛查（漏诊是致命的）、地震预警。
      * *口诀：* “所有的坏人，我都得抓到。”

### 4\. F1-Score —— 平衡大师

$$F1 = 2 \times \frac{Precision \times Recall}{Precision + Recall}$$

  * **含义：** 精确率和召回率的**调和平均数**。
  * **作用：** 只有当 Precision 和 Recall 都比较高时，F1 才会高。它比算术平均数更能惩罚极端情况（如果 Recall=0，F1 直接为 0）。

### 5\. ROC 曲线与 AUC 值

  * **ROC 曲线：** 横轴是 FPR（假阳性率），纵轴是 TPR（召回率）。我们希望 TPR 越高越好，FPR 越低越好。
  * **AUC (Area Under Curve)：** 曲线下的面积。
      * AUC = 0.5：瞎猜（随机）。
      * AUC = 1.0：完美分类器。
      * **优势：** 对**样本不平衡**不敏感，是很多算法比赛的首选指标。

-----

## 第二部分：回归模型指标 (Regression Metrics)

**场景：** 预测连续的数值（如：房价、气温、销量）。

### 1\. MAE (平均绝对误差 - Mean Absolute Error)

$$MAE = \frac{1}{m} \sum_{i=1}^{m} |y^{(i)} - \hat{y}^{(i)}|$$

  * **含义：** 预测值和真实值平均差了多少。
  * **特点：** 对异常值（Outliers）**不敏感**，比较鲁棒。如果你的数据里有很多奇怪的噪音点，用 MAE 比较稳。

### 2\. MSE (均方误差 - Mean Squared Error)

$$MSE = \frac{1}{m} \sum_{i=1}^{m} (y^{(i)} - \hat{y}^{(i)})^2$$

  * **含义：** 误差平方的平均值。
  * **特点：** 对异常值**非常敏感**。因为误差被平方了，大误差会被放大。
      * *例如：* 误差是 10，平方后是 100。如果你的业务不能容忍大错误，用 MSE。

### 3\. RMSE (均方根误差 - Root Mean Squared Error)

$$RMSE = \sqrt{MSE}$$

  * **含义：** MSE 开根号。
  * **特点：** 量纲（单位）回到了原始数据的量纲。
      * *例子：* 预测房价，MSE 的单位是“（万元）的平方”，很难理解；RMSE 的单位是“万元”，直观多了。

### 4\. $R^2$ Score (决定系数 - R-Squared)

$$R^2 = 1 - \frac{\sum (y^{(i)} - \hat{y}^{(i)})^2}{\sum (y^{(i)} - \bar{y})^2}$$

  * **含义：** 模型拟合优度的百分比。
      * $R^2 = 1$：完美拟合。
      * $R^2 = 0$：模型效果等同于直接猜平均值。
      * $R^2 < 0$：模型比瞎猜平均值还烂。
  * **作用：** MAE/RMSE 是绝对值，不同量级的数据无法比较（预测身高误差 5cm 和预测距离误差 5cm 概念不同）。**$R^2$ 归一化到了 0-1 之间，可以跨任务比较模型的“好坏程度”。**

-----

## 第三部分：一表总结与选择指南

| 任务类型 | 核心指标 | 适用场景 | 备注 |
| :--- | :--- | :--- | :--- |
| **分类** | **Accuracy** | 样本均衡，且对正负类判断同等重要时 | 最直观，但最容易骗人 |
| | **Precision** | **误报代价高** (如垃圾邮件、指纹解锁) | “宁缺毋滥” |
| | **Recall** | **漏报代价高** (如疾病诊断、金融风控) | “宁错杀不放过” |
| | **F1-Score** | 需要平衡 Precision 和 Recall 时 | 综合性能 |
| | **AUC** | 样本严重不平衡，或需要评估不同阈值时 | 鲁棒性最强 |
| **回归** | **MAE** | 数据中有较多异常值，不想被个别点带偏 | 抗干扰 |
| | **MSE / RMSE** | **严禁出现大误差**，对大错误零容忍 | 也是 Loss Function 的常用形式 |
| | **$R^2$** | 需要向非技术人员解释模型有多好时 | “我想知道解释了多少变化” |

-----

## 第四部分：Python 代码速查 (Sklearn)

```python
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# --- 分类模型 ---
y_true_cls = [1, 0, 1, 1, 0, 1]
y_pred_cls = [1, 0, 0, 1, 0, 1]
y_prob_cls = [0.9, 0.1, 0.4, 0.8, 0.2, 0.95] # 预测概率

print("--- 分类指标 ---")
print(f"Accuracy: {accuracy_score(y_true_cls, y_pred_cls):.2f}")
print(f"Precision: {precision_score(y_true_cls, y_pred_cls):.2f}")
print(f"Recall:    {recall_score(y_true_cls, y_pred_cls):.2f}")
print(f"F1 Score:  {f1_score(y_true_cls, y_pred_cls):.2f}")
print(f"AUC:       {roc_auc_score(y_true_cls, y_prob_cls):.2f}")

# --- 回归模型 ---
y_true_reg = [3.0, -0.5, 2.0, 7.0]
y_pred_reg = [2.5, 0.0, 2.0, 8.0]

print("\n--- 回归指标 ---")
print(f"MAE:  {mean_absolute_error(y_true_reg, y_pred_reg):.2f}")
print(f"MSE:  {mean_squared_error(y_true_reg, y_pred_reg):.2f}")
print(f"RMSE: {np.sqrt(mean_squared_error(y_true_reg, y_pred_reg)):.2f}")
print(f"R2:   {r2_score(y_true_reg, y_pred_reg):.2f}")
```

**下一步：**
在实际项目中遇到过**样本不平衡**的情况（例如正样本只有 1%）？
简单的 Accuracy 会失效，需要特殊的**重采样 (Resampling)** 或 **代价敏感学习**。